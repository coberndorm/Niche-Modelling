function classifiers=FrontierDistance(T,layerInfo,alpha,show,outlier,outlier2)
% classifiers=ColoringRadius(in,show,outlier,outlier2,alpha)
% 
% DESCRIPTION 
%   'coloringBorder' takes species presence-data(observations) over 
%   a map and generates a niche probability intensity map, by using the
%   radius.
%   Note: sample and point will be used interchangeably, as well as map
%   point and pixel.
%
% REQUIRED INPUTS
%   T: Table given by sampleVS with species samples and information
%   layerInfo: a structure generated by 'ReadLayers' function
%   
% OPTIONAL INPUTS
%   alpha: shrinking factor for the boundary, alpha=[0,1]   
%   show: if the boundary and the estimated map will show
%   outlier1: If the outliers are removed before normalization
%   outlier2: a integer with the number of required samples 
% 
% OUTPUTS:
%   classifiers.nodes: An array containing the boundary points with ther
%                       environmental covariates
%   classifiers.index: Indexes in T of the boundary points
%   classifiers.radius: radius of every point to its closest boundary point
%   classifiers.normalizers: normalization coefficients for environmental
%                            covariates
%   classifiers.T: Array of every sample data with their environmental
%                   covariate
%   classifiers.map: Array containing the probability  intensity of species
%                    presence in every map pixel
%%  

% Setting default values for alpha, show, and outlier detection
if nargin <3
    alpha = 1;
end
if nargin <4
    show = false;    
end
if nargin <5
    outlier=false;
end
if nargin <6
    outlier2=false;
end

%out1 and ouT will be the samples taken out by the outlier detection
out1=[];
ouT=[];

%preparing initial important data
Z = layerInfo.Z; % Enviromental Info in each point of the map
R = layerInfo.R; % Geographic cells Reference
reps = size(Z); % Size of Z
caps = reps(3); % Number of enviromental variables
template = Z(:, :, 1); % Array of map size
data = NaN(length(template(:)), caps); % 2D Array of the amount of pixels by enviromental variables

% Saves the enviromental variables of each pixel in the 2D array
for i = 1 : caps
    template = Z(:, :, i);
    data(:, i) = template(:); 
end

% Determine which pixels of the array are not part of the map
nanDetector = sum(data, 2);
pointer = ~isnan(nanDetector);
idx = find(pointer==1);

% Obtain the enviromental information of each sample
points = T{:,4:end};

% Normalizing the samples enviromental information 
normalizers=[max(points(:,:));min(points(:,:))]; 
points(:,:)=(points(:,:)-normalizers(2,:))./(normalizers(1,:)-normalizers(2,:));

% Normalizing the enviromental information of the map with the samples normalizers
data(idx,:) =  (data(idx,:)-normalizers(2,:))./(normalizers(1,:)-normalizers(2,:));

% Outlier detection before PCA
if outlier
    [~,~,RD,chi_crt]=DetectMultVarOutliers(points(:,:));
    id_out=RD>chi_crt(4);
    out1=points(id_out,:);
    points=points(~id_out,:);
end

% Dimensionality reduction to 3D with PCA
[coeff,~,~,~,explained]=pca(points(:,:));
pin=points(:,:)*coeff(:,1:3);

% If outliers were deleted, then the outliers deleted are also  
if ~isempty(out1)
    out1=out1*coeff(:,1:3);
end

% Outlier detection after PCA
if outlier2
    %siz=round(size(pin,1)*0.3);
    [~,~,RD,chi_crt]=DetectMultVarOutliers(pin);
    id_out=RD>chi_crt(4);
    ouT=pin(id_out,:);
    pin=pin(~id_out,:);
end

% defining the points that make up the frontier/boundary
nodes = boundary(pin(:,1),pin(:,2),pin(:,3),alpha);
boundPointsIndex = unique(nodes)'; %index of the points in T
boundPoints = points(boundPointsIndex,:); % Information of the frontier points
pointsSize = length(boundPointsIndex); % Size of the frontier array

% Array of the distance of each point to each frontier point
radius = zeros(pointsSize,samples); 

% Amount of samples
samples = length(points);

% Defining an array for the final map values
map = ones(reps(1), reps(2));

% Distance from each point to the frontier, including frontier points
for j=1:samples
    for i=1:pointsSize
        radius(i,j)=norm(points(boundPointsIndex(i),:)-points(j,:));
    end
end

% Deleting the frontier points from the radius array
radius = radius(:,setdiff(1:end,boundPointsIndex));

% Selecting only the minimum distance from each point to the frontier
radiusClass = min(radius);

% Creating an empty array to determine each pixel's distance to the frontier
response = NaN(pointsSize,length(template(:)));

% Calculating the distance of each map pixel to each frontier point
for i=1:length(idx)
    for j=1:pointsSize
        response(j,idx(i)) = norm(points(boundPointsIndex(j),:)-data(idx(i),:));
    end
end

% Selecting only the minimum distance from each pixel to the frontier
intensity = min(response(:,idx));

% Creating an empty array to determine each pixel's intensity
final = NaN(length(template(:)),1);

% Calculating each pixel's intensity by checking if the distance to the frontier 
% of each pixel is less than that of the samples to the frontier points
for i=1:length(idx)
    final(idx(i)) = sum(intensity(i)<=radiusClass);
end
final(idx) = final(idx)./(length(radiusClass));

% Going back from a 1d array to a 2d array
map(:) = final(:);

classifiers.nodes = boundPoints;
classifiers.index = boundPointsIndex;
classifiers.radius = radiusClass;
classifiers.normalizers = normalizers;
classifiers.T = T;
classifiers.map = map;

outT=[out1;ouT];

% Plot the frontier and the coloured map
if show
    trisurf(nodes,pin(:,1),pin(:,2),pin(:,3), 'Facecolor','cyan','FaceAlpha',0.8); axis equal;
    hold on
    plot3(pin(:,1),pin(:,2),pin(:,3),'.r')
    hold off
    

    figure
    clf
    geoshow(map, R, 'DisplayType','surface');
    contourcmap('jet',0:0.05:1, 'colorbar', 'on', 'location', 'vertical')
end
    

if isempty(outT)
    grap=false;
else
    grap=true;
end