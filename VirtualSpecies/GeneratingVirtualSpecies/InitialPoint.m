function InitialPoint = InitialPoint(Layers, method, plotting, random_point, point, coeff, deformations_limit)
%   InitialPoint = InitialPoint(layers, method, plotting, random_point, point, coeff, deformations_limit)
% 
% DESCRIPTION:
%   Calculates the distance from an initial point to the rest of the pixels
%   in a set of layers. The distance is used to determine the sorting order
%   of the layers for further processing.
%
% REQUIRED INPUTS
%   Layers: a structure generated by 'ReadLayers' function.
%
% OPTIONAL INPUTS:
%   method: a string indicating the method to be used for generating
%           deformations. Possible values are 'coeff', 'beta', and 'harmonic'.
%           Default is 'coeff'.
%   plotting: a boolean variable (true, false) indicating whether to show
%             plots during the deformation process. Default is false.
%   random_point: a boolean variable (true, false) indicating whether to use
%                 a random initial point. Default is true.
%   point: an array of [layer_num,1] of a chosen initial point.
%   coeff: an array of [layer_num,1] of scalars [0,1] to warp the variable
%          space. Default is a random array.
%   deformations_limit: a scalar indicating the number of harmonics to use 
%                       for generating deformations if 'harmonic' method is 
%                       used. Default is 2.
%
% OUTPUTS:
%   InitialPoint: a structure containing:
%       -idx: an array of [1, Rows] containing the sorted indices of the layers
%             based on their distance from the initial point.
%       -SortNormDistance: an array of [1, Rows] containing the sorted
%             distances of the layers from the initial point. 

    % Read input data
    layer_num = Layers.Dimensions(2);
    hypercube = true;

    if hypercube
        Range = [zeros(layer_num,1), ones(layer_num,1)]';
        norm_climate_vars = UniformSampler(Range, layer_num, 1e4, 'LatinHypercube', false)';
        rows = 1e4;
    else
        rows = Layers.Dimensions(1);
        norm_climate_vars = Layers.NormalizedClimVar;
    end
    distance = zeros(1, rows);

    % Check input arguments
    if nargin < 2
        method = 'coeff';
    end
    if nargin < 3
        plotting = false;
    end
    if nargin < 4
        random_point = true;
    end
    if nargin < 5
        if random_point == true
            point = rand(layer_num, 1);
        else
            idx = randi([0,rows]);
            point = norm_climate_vars(:,idx);
        end
    end
    if nargin < 6
        coeff = rand(layer_num, 1);
    end
    if nargin < 7
        deformations_limit = 3;
    end
    
    
    % Perform method based on selected option
    switch method
        case 'coeff'
            % Normalize the coefficients
            coeff = coeff/sum(coeff);
            
            % Multiply the point and the normalized climatic variable by the normalized coefficients
            point = point.*coeff;
            norm_climate_vars = norm_climate_vars.*coeff;
            
            % Calculate distance using norm and corr2
            for i = 1: rows
                distance(i) = norm(point - norm_climate_vars(:, i))...
                * (2 - corr2(point, norm_climate_vars(:, i)));
            end
            
            % Normalize distance and store it in norm_distance
           norm_distance = normalize(distance, 2, 'range');

        case 'beta'
            % Call the BetaDeformations function and store its output
            beta_deformations = BetaDeformations(norm_climate_vars,point,layer_num,rows,plotting);
            norm_climate_vars = beta_deformations.ClimVar;
            point = beta_deformations.NewPoint;
            
            % Calculate distance using norm and corr2
            for i = 1: rows
                distance(i) = norm(point - norm_climate_vars(:, i))...
                * (2 - corr2(point, norm_climate_vars(:, i)));
            end 
            
            % Normalize distance and store it in norm_distance
            norm_distance = normalize(distance, 2, 'range');

        case 'harmonic'
            % Call the HarmonicDeformations function and store its output
            H = HarmonicDeformations(norm_climate_vars, layer_num, deformations_limit, plotting);
            
            % Calculate distance using harmonic distances
            norm_distance = 1 - H.Distances;

        otherwise
            % Throw an error if method is not valid
            error('Invalid method');
    end
    
    % Invert the distances
    norm_distance = 1 - norm_distance;
    
    % Sort the distances and store the indices
    [sorted_norm_distance, idx] = sort(norm_distance, 2, 'descend');
    
    % Store output information
    InitialPoint.idx = idx;
    InitialPoint.SortNormDistance = sorted_norm_distance;
    InitialPoint.NormDistance = norm_distance;
end
function hypercube_samples = UniformSampler(range, N, samples, method, plotting)
    % UniformSampler Generates uniform samples in a hypercube.
    %
    %   hypercube_samples = UniformSampler(range, N, samples, method, plotting)
    %   generates uniform samples in an N-dimensional hypercube defined by
    %   the specified range. The method parameter determines the sampling
    %   technique, with options 'Sobol' (default) and 'LatinHypercube'.
    %
    %   Input Arguments:
    %       - range: A 2xN matrix defining the lower and upper bounds of the
    %                hypercube along each dimension.
    %       - N: The number of dimensions of the hypercube.
    %       - samples: (Optional) Number of samples to generate. Default is 10,000.
    %       - method: (Optional) Sampling method, 'Sobol' or 'LatinHypercube'.
    %                 Default is 'Sobol'.
    %       - plotting: (Optional) Logical flag indicating whether to plot
    %                   the generated samples. Default is false.
    %
    %   Output:
    %       - hypercube_samples: Generated uniform samples within the hypercube.
    %
    %   Examples:
    %       % Default usage with Sobol sequence
    %       samples = UniformSampler([0, 1; 2, 3], 2);
    %
    % If samples not specified, set it to 10,000
    if nargin < 3
        samples = 1e4;
    end
    
    % If method not specified, set it to Sobol
    if nargin < 4
        method = 'Sobol';
    end

    if nargin < 5
        plotting = false;
    end


    switch method
        case 'Sobol'
            p = sobolset(N);
            p = scramble(p,'MatousekAffineOwen');
            hypercube_samples = net(p, samples) .* (ones(samples, 1) * (range(2, :)-range(1, :)) ) + ones(samples, 1) * range(1, :);
        case 'LatinHypercube'
            hypercube_samples = lhsdesign(samples, N) .* ( ones(samples,1) * (range(2, :) - range(1, :)) ) + ones(samples, 1) * range(1, :);
    end

    if plotting
        sdo.scatterPlot(array2table(hypercube_samples))
    end
end
